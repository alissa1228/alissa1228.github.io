---
layout: post
title:  "CSR, SSR 훑어보기"
date:   2024-01-26
categories: jekyll update
---

<br/>
<br/>

## # 웹 브라우저 렌더링?🤔


웹 브라우저 렌더링이란 **실시간으로 웹 사이트가 그려지는 과정**으로 HTML, CSS, JavaScript 등 개발자가 작성한 코드가 브라우저에서 출력되는 과정을 일컫는다. 

웹 브라우저가 웹 페이지를 여는 과정은 압축파일을 여는 것과 비슷하다. 파일을 받아 압축을 풀게 되면 웹 페이지 화면이 그려지는데 이 과정을 돕는 게 바로 브라우저의 렌더링 엔진이다. 렌더링 엔진은 Webkit(사파리), Blink(크롬/오페라), Gecko(파이어폭스) 등 다양하다. 각 브라우저 엔진은 각자 고유의 기능과 최적화 방법을 가지고 있다. (프론트엔드 개발자들이 크로스 브라우징 호환성에 시간을 들이는 이유..) 

브라우저 엔진은 웹 서버로부터 파일을 받아 사용자 디스플레이에 페이지를 구성하는데, HTML 구문을 해석해 DOM 트리를 만들고 CSS소스로 CSS DOM이라는 스타일링 객체를 구성한다. 이 때 HTML 구문을 만드는데 있어 웹서버가 다 만들 수 있고, 웹 서버에서 초기 HTML을 받은 후 대부분의 내용은 브라우저가 생성해 붙일 수도 있다.

간략하게 **웹 서버가 HTML 구문을 다 만드는 전자의 방식이 SSR**, *초기 HTML만 받아 대부분의 내용을 브라우저가 만드는 후자의 방식이 CSR*다. 

<br/>

## # CSR(Client Side Rendering)


CSR은 클라이언트 사이드 렌더링(Client Side Rendering)으로 렌더링 작업이 사용자의 브라우저, 즉 클라이언트 측에서 진행된다. 초기 페이지 로드시 서버에서부터 파일을 받은 뒤 브라우저가 렌더링 한다고 보면 된다. (따라서 CSR은 브라우저가 많은 일을 처리하게 된다) 동작 순서는 아래와 같다

<br/>

1. 사용자가 웹 페이지를 방문하면 브라우저(클라이언트)는 필요한 자원을 서버에 요청한다.
2. 요청을 받은 서버가 **뼈대만 있는 HTML 파일과 자원을 브라우저에 전송**한다.
3. 브라우저가 HTML 파일을 해석해 DOM 트리 작성, 자바스크립트 번들 파일 등을 다운로드 한다. (이벤트 리스너도 DOM 트리가 생성될 때 포함된다)
4. 이후 브라우저(클라이언트)쪽  JavaScript 엔진으로 인해 JavaScript 코드가 실행되어 브라우저에 콘텐츠가 동적으로 렌더링 된다. (Hydration - 사용자 인터렉션이 가능한 동적인 컴포넌트를 생성하는 과정. 정적인 웹을 동적으로 변화시키는 단계.) 
	- React, Vue, Angular 등의 프레임워크에서는 이 때 가상 DOM이 최초로 생성된다. 
5. 브라우저에 콘텐츠가 렌더링 되는 시점에서만 페이지를 볼 수 있고 상호 작용도 이 때 가능하다. 

<br/>

- 장점
	- 서버가 빈 뼈대만 있는 HTML을 넘겨주는 역할만 수행하기 때문에 서버 측의 부하가 적다.
	- 클라이언트에서 연산, 라우팅 등을 모두 직접 처리하기 때문에 반응 속도가 빠르고 UX도 우수하다.
	- 동적인 웹사이트를 만드는데 적합하며 페이지의 일부분만 업데이트 해야할 때 유용하다
	- 앱이 더 반응적이고 사용자가 페이지 간 전체 페이지 새로고침을 보지 않아도 된다.
	- TTV(Time To View)와 TTI(Time To Interact) 간 시간 간격이 없다.

- 단점
	- 브라우저가 JS가 파일을 다운 받고 동적으로 DOM을 생성하는 시간을 기다려야하기 때문에, 초기 로딩 시간이 느려져 사용자를 기다리게 할 수 있다.
	- 초기 HTML을 받아왔을 때 빈 페이지기 때문에 크롤러가 인식하기 힘들어 검색 엔진 최적화(SEO)에 불리하다

<br/>

## # SSR(Server Side Rendering)


SSR은 서버 사이드 렌더링(Server Side Rendering)으로 웹 서버에서 사용자에게 보여줄 페이지를 모두 구성해 브라우저에게 넘겨주는 방식이다. 사용자가 페이지에 접속할 때마다 서버가 해당 페이지의 완성된 HTML을 생성해 브라우저로 보내며, 각 페이지 URL 마다 보여줄 내용이 미리 결정되어 있다. 사용자가 웹 페이지에 접속하면 브라우저가 해당 URL을 서버에 요청하고 서버는 해당 url을 기준으로 어떤 페이지를 렌더링 할지 결정한다. 

<br/>

1. 유저가 웹 페이지에 접속하면 브라우저가 해당 url을 서버에 요청한다
2. 서버는 url을 기준으로 렌더링할 페이지를 정한다
3. 서버는 페이지에 필요한 데이터를 얻어와 CSS 삽입까지 마친 후, **렌더링 준비를 끝낸 HTML(+JS 파일 등)을 클라이언트에 보낸다** (모든 데이터가 모두 HTML에 담겨진 채로 브라우저에 전달. 상호작용은 X)
4. 브라우저는 이를 받아 바로 페이지를 띄우고(사용자는 화면을 바로 볼 수 있다.) JS 코드를 다운 받아 HTML에 JS 로직을 연결한다.

<br/>

- 장점
	- 사용자에게 빠르게 초기 페이지를 보여줄 수 있다. (초기 구동 속도가 빠르다)
	- 검색 엔진이 사이트를 쉽게 크롤링할 수 있어 검색 엔진 최적화(SEO)에 유리하다

- 단점
	- 사용자의 각 요청에 따라 서버가 페이지 전체를 새로 렌더링 해야하기 때문에 서버 부하가 커질 수 있다.
	- 화면 깜빡임이 있다.
	- TTV(Time To View)와 TTI(Time To Interact) 간 시간 간격이 존재한다.

<br/>

## # 그럼 각각 언제 쓰는 지..?


선택은 애플리케이션의 요구 사항이나 성격에 따라 다르다. SEO가 중요한 사이트라면 CSR보다 SSR 방식을 좀 더 고려할 것이고 사용자와 상호작용이 더 많고 동적 요소가 많이 들어가 있는 사이트는 등은 CSR을 더 선호할 수 있다. CSR과 SSR을 같이 쓰는 전략도 있다고 하지만 각각의 사용 시점을 간략히 정리하면 아래와 같다. 

<br/>

- CSR 사용 시점
	- 복잡한 UI와 많은 기능을 가진 애플리케이션에 적합하다.
	- 대량 및 동적 데이터를 다루는 애플리케이션에 좋다.
	- 사이트에서 쓰기 작업이 읽기 작업보다 빈번한 경우에 유리하다.
	- 많은 사용자를 가진 사이트에 적합하다.

<br/>

- SSR 사용 시점
	- 요청 시 즉시 서버가 HTML을 만들어서 응답하기 때문에 데이터가 달라져서 미리 만들어두기 어려운 페이지에 적합하다
	- UI가 간단하고 기능이 적은 애플리케이션에 적합하다.
	- 동적 데이터가 적은 애플리케이션에 좋다.
	- 사이트의 읽기 작업이 쓰기 작업보다 많은 경우에 유리다.
	- 리치 사이트에 초점을 맞추지 않고 사용자 수가 적은 애플리케이션에 적합하다.

<br/>

대락적으로 정리 했지만 브라우저와 서버가 각각 어떤 역할을 맡는 지를 이해하고 서비스 목적에 따라 적합한 렌더링 방식을 취하면 되겠다.

<br/>

📌 참고

- [https://yozm.wishket.com/magazine/detail/646/](https://yozm.wishket.com/magazine/detail/646/)
- [https://yozm.wishket.com/magazine/detail/2330/](https://yozm.wishket.com/magazine/detail/2330/)
- [브라우저 렌더링 엔진_위키백과](https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%EC%97%94%EC%A7%84)
- [https://ferie.medium.com/what-is-the-client-side-rendering-and-how-it-works-c90210e2cd14](https://ferie.medium.com/what-is-the-client-side-rendering-and-how-it-works-c90210e2cd14)
- [https://www.youtube.com/watch?v=YuqB8D6eCKE&t=26s](https://www.youtube.com/watch?v=YuqB8D6eCKE&t=26s)

<br/>
<br/>
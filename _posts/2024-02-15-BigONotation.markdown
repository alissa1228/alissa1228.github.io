---
layout: post
title:  "[알고리즘] 시간복잡도와 공간복잡도, Big O 표기법 훑어보기"
date:   2024-02-15
categories: jekyll update
---

<br/>
<br/>


안녕하세요. 오늘은 알고리즘 공부를 하기 전 알아두어야 할 개념인 '시간 복잡도'와 '공간 복잡도' 그리고 Big O 표기법(빅오 표기법)을 훑어보고자 합니다. 알고리즘은 <b>어떤 문제를 해결하기 위해 밟아 나가는 일련의 절차</b> 혹은 <b>어떠한 문제를 해결하기 위한 동작의 모임</b>을 말합니다. 알고리즘은 어떠한 경우에도 항상 같은 실행결과가 나와야 하며, 이 결과가 알고리즘이 해결하는 문제의 정확한 답이어야 합니다. 

우리가 문제를 해결하는데 있어 효율이 가장 좋은 방법을 찾아내 적용하듯이 알고리즘도 마찬가지입니다. 코딩 테스트 문제를 풀 때도 다양한 알고리즘 중에 가장 최선의 알고리즘을 찾아내 풀어야 합니다. 이 때 필요한 기준이 바로 시간 복잡도와 공간 복잡도 입니다.

<br/>

--------

<br/>

### **#복잡도?** 🤔

<br/>

**복잡도(complexity)는 알고리즘의 성능을 나타내는 척도**입니다. 복잡도는 시간복잡도와 공간복잡도로 나뉘는데 간략하게 말하자면 

- 시간 복잡도는 '알고리즘을 위해 필요한 **연산의 횟수**' 
- 공간 복잡도는 '알고리즘을 위해 필요한 **메모리의 양**'  

정도로 요약해볼 수 있습니다. 복잡도가 낮을 수록 좋은 알고리즘이며, 두 복잡도를 각각 정리하자면 아래와 같습니다. 

- 시간 복잡도(Time Complexity).
	- 입력 크기에 대한 연산 횟수의 상한을 뜻합니다. 
    - 즉, 입력이 커질수록 알고리즘의 실행 속도가 어떻게 바뀌는지를 말합니다. (=입력에 따라 알고리즘의 연산 횟수가 얼마나 늘어나고 시간이 얼마나 걸리는지)
    - 가장 효율적으로 해결하는 알고리즘을 찾기 위한 기준이자 알고리즘의 성능을 나타내는 지표이기도 합니다. 
	- 알고리즘의 시간 복잡도는 주로 Big O 표기법을 사용하며 나타낸다.

<br/>

- 공간 복잡도(Space Complexity)
    - 입력이 커질 수록 알고리즘이 얼마나 많은 공간을 차지 하는지를 말합니다. 
    - 여기에서 공간은 프로그램 자체가 차지하는 메모리를 말합니다. (=입력이 커질 수록 얼마나 많은 공간(사용되는 메모리)를 차지 하는지')
    - n의 크기에 따라 알고리즘이 데이터를 저장하기 위해 사용되는 메모리가 달라집니다.
    - 일반적으로 메모리 사용량 기준은 MB로 제시됩니다. 

<br/>

### **#복잡도를 표현하는 방법, Big O 표기법**


<br/> 

Big O 표기법(Big O Notation)은 n(입력값)이 커짐에 따라 알고리즘의 시간 또는 공간의 요건이 얼마나 커지는가를 나타내는 방법을 말합니다. 입력이 증가함에 따라 알고리즘의 실행 시간이 어떻게 변화하는지 설명하는 방식입니다. 빅오 표기법은 알고리즘 수행 시간을 대략적으로 나타내는 방법인 점근 표기법 중 하나 입니다. 대표적인 점근 표기법은 아래와 같습니다.

<br/>

- O(Big O) 표기법: 알고리즘 성능이 최악인 경우(수행 시간의 상한)를 나타낼 때 사용(가장 느린 케이스)
- Ω(Big Omega) 표기법:  알고리즘의 성능이 최선인 경우(수행 시간의 하한)를 나타낼 때 사용 (가장 빠른 케이스)
- Θ(Big Theta) 표기법: 알고리즘이 처리해야 하는 수행 시간의 상한과 하한을 동시에 나타냄 (평균적인 케이스)

<br/>

이 중 최악의 경우에 대한 알고리즘 수행 시간이 가장 쓸모가 많기 때문에 알고리즘 성능 표기법으로는 Big O가 가장 많이 쓰입니다. 빅오의 핵심은 아래와 같습니다.

> 만약 어떤 문제에 해결책이 2개가 있다면? 하나는 루프를 사용하고, 하나는 리스트나 문자열을 이용한다고 한다면 어떤 게 더 좋을까?

<br/>

이 때 사용되는 게 바로 빅오 입니다. O(n), O(1) 등의 빅오 표기법을 통해 여러가지 코드를 비교하고 성능을 평가해 최선의 알고리즘을 찾을 수 있습니다. Big O 표기법에서 가장 많이 사용되는 함수를 가장 효율적인 최선에서 가장 비효율적인 최악의 순서로 나열한다면 아래와 같습니다.

<br/>

> 상수 시간(가장 효율적) -> 로그 시간 -> 선형 시간 -> 선형 로그 시간 -> 2차 시간 -> 3차 시간 -> 지수 시간(가장 비효율적)

<br/>

우리는 이중에서도 상수 시간과 선형 시간을 살펴보고자 합니다. 예시를 사용해 살펴보겠습니다. 

<br/>

```javascript

function add(n) {
    let total = 0;
    for (let i=i; i<=n;i++) {
        total += i
    }
    return total;
}

```


```javascript

function add(n){
    return n * (n+1) /2
}

```
<br/>

이 두 개의 예시 중 어떤 게 더 나을까요? 여기에서 더 낫다는 기준은 '어떤 코드가 더 빠르게 실행될까요?'로 하곘습니다. (보통 복잡도를 말할 때 시간 복잡도로 이야기 하니까요.) 답을 먼저 말하자면 두 번째 예시가 복잡도가 낮아 더 최선의 알고리즘이라고 볼 수 있습니다. 

<br/>

### **#어떻게 구했냐면...✍️**

<br/>

시간 복잡도에서는 **'컴퓨터가 처리해야할 연산 갯수'**를 세면 됩니다. 여기에서 연산은 더하기, 뺄셈, 곱셈, 나누기 등을 말합니다. 두 번째 예시를 살펴볼까요? 두 번째 예시에는 곱하기(*), 더하기(+), 나누기(/) 이렇게 세 가지 연산이 있습니다. 예시의 n 값에 숫자를 넣어 진행해보겠습니다.

<br/>

```javascript

function add(3){
    return 3 * (3+1) /2
    //6
}

function add(6){
    return 6 * (6+1) /2
    //21
}


```
<br/>

해당 예시에서는 n에 어떤 숫자를 집어넣든지 간에 연산은 세 번 이루어집니다. 곱하고 더하고 나누고. 끝이에요! n이 커져도 실행시간에는 아무 영향을 받지 않는 두번 째 예시는 O(1)로 표현할 수 있습니다. (3번인데 왜 1로 표현하느냐고 물어볼 수 있겠습니다만, 아래에서 다시 이야기 하겠습니다.) 이에 비해 첫 번째 예시를 살펴보면 'total +=1'에서 볼 수 있는 더하기 연산은 for 문 안에서 이루어지는 걸 볼 수 있습니다. 루프는 n의 값만큼 돌아가므로 연산도 n의 값만큼 실행됩니다. 여기도 n 값에 숫자를 넣어볼까요. 

<br/>

```javascript

function add(3) {
    let total = 0;
    for (let i=1; i<=3;i++) {
        total += i
    }
    return total;
    // 6

}

function add(5) {
    let total = 0;
    for (let i=1; i<=5;i++) {
        total += i
    }
    return total;
    // 15
}
```

<br/>

입력한 n 값에 따라 연산 횟수가 달라지는 걸 볼 수 있습니다. n이 커질수록 연산긔 갯수가 비례적으로 늘어납니다. 우리는 n이 커질 수록 실행시간이 같이 늘어나는 첫 번째 예시를 O(n)으로 표현할 수 있습니다. i++도 있고 n 값에 따라 변하는 i<=n도 있는데 왜 O(n)이냐, O(3n)이나 뭐 이렇게 해야하는 거 아니냐 하시겠지만, 빅오는 상수를 없애고 단순화해서 비교하기 때문 상수가 붙더라도 O(n), O(1), O(n^2) 등으로 단순화 합니다. 

이렇게 오늘은 간략하게 시간복잡도, 공간 복잡도와 Big O 표기법이 무엇인지, 그 중 상수 시간과 선형 시간을 살펴보았습니다. 다음에는 남은 Big O 표기법을 예시를 통해 살펴보고 제대로 이해해보고자 합니다. 그럼 안녕!👋


<br/>


📌 참고
- [https://wikidocs.net/222560](https://wikidocs.net/222560)
- [https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
- [시간복잡도 - 위키백과](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84)
- [자바스크립트 알고리즘 & 자료구조 마스터 클래스(유데미)](https://www.udemy.com/course/best-javascript-data-structures/learn/lecture/28559303#content)
- [시간복잡도 시각화 사이트](https://rithmschool.github.io/function-timer-demo/)
- [https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS7965376216](https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS7965376216)
- [나동빈님의 책 '이것이 취업을 위한 코딩테스트다 with 파이썬'](https://m.yes24.com/Goods/Detail/91433923)
- [알고리즘 복잡도란](https://velog.io/@ka0ka0ka/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%9E%80)



<br/>
<br/>
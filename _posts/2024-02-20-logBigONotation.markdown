---
layout: post
title:  "[알고리즘] 시간복잡도 로그 시간, 지수시간 등 더 훑어보기"
date:   2024-02-20
categories: jekyll update
---

<br/>
<br/>

[Previously on...](https://alissa1228.github.io/jekyll/update/2024/02/15/BigONotation.html)

이전 포스팅에서는 가장 효율적인 상수 시간 O(1)과 선형 시간 O(n)을 예시로 들어 시간 복잡도를 구하는 방법을 설명했었습니다. 이번 포스팅은 지난 번에 이어 Big O 표기법을 더 살펴보려고 합니다. 

<br/>

--------

<br/>
<br/>

### **#일단 로그(log)란?** 

<br/>



로그는 지수를 다른 방법으로 표현한 거라 보면 됩니다. 나눗셈과 곱셈이 짝인 것처럼 로그함수와 지수함수는 짝이라고 보시면 됩니다. 아래 예시를 살펴보면 지수와 로그 식이 있는데, 여기에서 우리는 로그의 핵심은 '2의 몇승이 되어야 8이 나오는가?'가 임을 알 수 있습니다. 


```
//지수
2^3 =8 

//로그
log2(8) = 3

//
log2(진수) = 지수 -> 2^지수 = 진수

```

<br/>

<br/>

### **#로그 시간 복잡도(Logarithmic Time Complexity)**

<br/>

로그 시간 복잡도는 상수 시간 다음으로 효율이 좋은 시간 복잡도 입니다. Big O 표기법에서는 O(log n)으로 표기합니다. 입력 데이터의 크기가 주어졌을 때 처리 시간이 로그(log)만큼 짧아지는 알고리즘 입니다. 입력값 n이 주어졌을 때 문제를 해결하는 단께가 연산마다 특정요인에 의해 줄어듭니다. 입력이 몇 배로 증가해도 실행 절차는 약간씩만 커지기 때문에 로그 함수는 큰 입력이 많은 경우에 효율이 좋습니다. 예시를 한 번 볼까요?

 <br/>

```javascript

function paint(n) {
    for(let i=2;i<n;i*=2) {
        const result = i;
    }
}

// n = 10 일 때 - 2,4,8
// n = 20 일 때 - 2,4,8,16
// n= 100 일 때 - 2,4,8,16,32,64
 
```
<br/>

예시를 보면 N 값이 몇 배씩 늘어나도 실행되는 횟수는 크게 늘지 않습니다. 처음 넣었던 10 이라는 입력값의 실행 횟수와 그보다 10배인 100 입력값의 실행 횟수를 살펴보면 크게 증가 하지 않았다는 걸 확인할 수 있습니다. 실제로도 로그 계산기를 두들겨보면 log2(10)=3.321928...  / log2(100) = 6.64385...으로 약간 올라갔을 뿐입니다. 이런 특징 때문인지 로그 시간 복잡도는 실행을 반복할 때마다 알고리즘 탐색 범위를 반으로(1/2로) 줄여나가는 이진 탐색과 같은 알고리즘에서 볼 수 있습니다.  (이진 탐색은 큰 데이터 세트에서도 빠른 검색 속도를 가능하게 하는 알고리즘입니다.)

<br/>


### **#선형 로그 시간(Log-Linear Time)**

<br/>

선형 로그 시간은 로그 시간 복잡도와 선형 시간 복잡도를 곱한 만큼 커집니다. 로그 시간으로 실행되는 알고리즘은 입력값인 N번 반복하는 형태이기 때문에 n * logN 이라고 볼 수 있습니다. 위에서 언급했던 로그 식을 통해 살펴보겠습니다.

<br/>

```
//logN
log2(8)=3
log2(16) =4

// N * logN

8 * log2(8) = 24
16 * log2(16) = 64

```

<br/>

선형이라는 이름이 붙읕 만큼 n이 커질 수록 값은 커집니다. 대표적인 알고리즘으로는 병합 정렬 알고리즘, 퀵 정렬 알고리즘이 있습니다. 아래는 O(n log n)의 예시입니다.

<br/>

```javascript

function print(arr) {
  let count = 0;
  for (let i = 1; i < arr.length; i++) { //선형 시간 부분 O(n)
    for (let j = 2; j < arr.length; j*=2) { //로그 시간 부분 O(log n)
      count += 1;
    }
     console.log(count); // arr.length = 8 일 때 count는 8 * log2(8) 로 계산되어 count는 24가 된다. 
  }
}

```
<br/>

첫 번째 루프 부분은 입력받는 배열 길이에 비례해 반복하기 때문에 O(n) 이라고 볼 수 있습니다. 두 번째 내부 루프는 j 값이 루프할 때마다 두 배씩 증가하는데, j가 2의 거듭제곱으로 증가하기 때문에(1,2,4,8,16...) 'n'의 크기에 대해 로그 스케일로 반복 횟수가 증가하기 때문에 O(logN)으로 볼 수 있습니다. (입력 받는 배열의 길이가 8이라고 하면 j는 1,2,4에서 멈추게 됩니다. 그럼 3번의 반복이며 이는 log2(8)=3에 해당하게 됩니다.) count의 증가 횟수는 배열의 크기에 대한 로그 함수의 곱에 비례하게 되므로 시간복잡도가 O(n log n)
이 됩니다. 



<br/>

### **#2차 시간 복잡도(Quadratic Time Complexity) & 3차 시간 복잡도(Cubic Time)**

<br/>

2차 시간 복잡도는 n의 제곱에 정비례 하며 O(n^2)로 표기 합니다. 입력 데이터의 크기에 따라 걸리는 시간이 제곱에 비례하며 이중 루프 내에서 입력 데이터를 처리하는 경우에 나타납니다. 즉, n 값이 커지면 커질 수록 문제를 해결하는 단계의 수가 겉잡을 수 없게 늘어나게 되는 겁니다..보통 n의 제곱에 비래해 실행 시간이 늘어나는 삽입 정렬이나 버블 정렬과 같은 정렬 알고리즘 등이 2차 시간 복잡도를 갖습니다. 

<br/>


```javascript

function paint(n){
    for(let i=0; i< n;i++;){ //O(n)
       for(let j=0; j<n;j++) { //O(n)
        console.log(i,j);
       } 
    }
}

//n = 2

// 0 0 
// 0 1
// 1 0
// 1 1
// 총 4번 (2의 제곱)

```
<br/>

3차 시간 복잡도는 2차에서 제곱에 비례 했다면 여기는 n의 세제곱에 비례합니다. O(n^3)으로 표기하며 보통 3중 루프일 때 나타납니다. 데이터 과학이나 통계 관련 일에서 3차 시간 복잡도 문제를 자주 접할 수 있습니다. 

<br/>

```javascript

function paint(n){
    for(let i=0; i< n;i++;){ //O(n)
       for(let j=0; j<n;j++) { //O(n)
          for(let t=0; t<n;t++) { //O(n)
                console.log(i,j,t);
       } 
       } 
    }
}
//n = 2

// 0 0 0
// 0 0 1 
// 0 1 0
// 0 1 1
// 1 0 0
// 1 0 1
// 1 1 0
// 1 1 1
// 총 8번 (2의 세제곱)

```

<br/>




### **지수 시간 복잡도(Exponential Time Complexity)**

<br/>

두둥 드디어 최악의 시간 복잡도인 지수 복잡도 입니다. 지수 시간 복잡도는 O(C^n)으로 표시하며 n 입력 값의 크기에 따라 상수값 C의 n 제곱만큼 비례합니다. 보통 피보나치 수열 등에서 많이 보입니다. (피보나치 수열에서 각 숫자는 바로 앞의 두 숫자를 더한 것과 같다.) 지수 시간 복잡도 예시는 아래와 같습니다. 

<br/>

```javascript

let pin = 931;
let n = pin.toString().length;
for (let i = 0; i < Math.pow(10, n); i++) {
  if (i === pin) {
    console.log(i,n);
  }
}

//Math.pow() -> 2^3 처럼 밑(base)에 지수(Exponent)를 제곱한 값을 반환하는 함수
//ex) Math.pow(2,3) -> 2^3 = 8

```

<br/>

위 코드는 pin에 할당된 숫자를 문자열로 변환한 후 length를 구해 n 변수에 할당됩니다. 이후 루프가 시작되고 Math.pow() 함수에 따라 Math.pow(10,3) 즉 10의 세제곱 보다 작을 때까지 1씩 증가하며 돌아갑니다. (따라서 지수 시간 복잡도에 해당 되어 O(10^n)으로 표기합니다.) 그러다 i가 Pin과 같은지 확인하고 만약 같다면 콘솔에 값을 출력합니다. 이렇게 모든 가능성을 하나씩 시도해 보는 수단을 무차별 대입 알고리즘(Bruce-Force Algorithm)이라고 합니다. 


<br/>

----------

<br/>


이렇게 시간복잡도와 Big O 표기법에 대해 좀 더 알아보았습니다. 이번 포스팅에서는 시간 복잡도와 연관된 알고리즘 종류도 조금 더 써보았는데요, 문제와 이슈에 맞는 적절한 알고리즘을 찾는 게 정말 중요하다고 느껴집니다. 다음에는 오늘 언급한 알고리즘이나 자료구조를 조금 더 공부해볼까 합니다. 그럼 안녕~! 👋


<br/>




📌 참고
- [시간복잡도 정리 및 예제](https://itprogramming119.tistory.com/entry/Javascript-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EC%98%88%EC%A0%9C)
- [한빛 미디어 - 시간복잡도와 Big O 표기법](https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS7965376216)
- [자바스크립트 Big O 예시](https://medium.com/@su_bak/algorithm-big-o-%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C-b3cbb5e248e5)
- [알고리즘의 시간 복잡도와 Big O 쉽게 이해하기)](https://blog.chulgil.me/algorithm/)
- [알고리즘 시리즈 - 시간 복잡도](https://joontae-kim.github.io/2021/04/15/algorithm-big-O/)


<br/>
<br/>
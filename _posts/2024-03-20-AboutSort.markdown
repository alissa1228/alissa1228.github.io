---
layout: post
title:  "[알고리즘] '정렬'에 대해 알아보자"
date:   2024-03-20
categories: jekyll update
---

<br/>
<br/>


### #정렬 알고리즘(Sorting Algorithm)이란?

<br/>

컴퓨터 과학과 수학에서 정렬 알고리즘은 원소들을 번호 순이나 사전 순서 같이 일정한 순서대로 열거하는 알고리즘이다. 예를 들어 학생들 목록이 있다면 학점이라는 키로 데이터 집합을 일정한 순서로 정렬할 수 있다. 여기에서 작은 데이터를 앞 쪽에 놓고 싶다면 '오름차순(ascending order)'를, 큰 데이터부터 앞에 놓고 싶다면 '내림차순(descending order)'로 정렬하면 된다. 정렬 알고리즘은 데이터를 정렬해 검색을 쉽게 만들거나 다른 알고리즘을 최적화 하는데 쓰인다. <b>정렬 알고리즘의 핵심은 교환, 선택, 삽입이다.</b> 대부분의 정렬 알고리즘은 이 세 가지를 응용하며 정렬을 완료한다. 

<br/>

정렬 알고리즘에는 다양한 정렬 방식이 있는데 이 포스팅에서는 선택정렬, 버블정렬, 삽입정렬, 퀵 정렬, 병렬 정렬을 살펴보려고 한다. 

<br/>

---



<br/>

### #버블 정렬(Bubble Sort)

<br/>

버블정렬은 시간복잡도가 O(n^2)으로 느리지만 코드가 단순하기 때문에 자주 사용된다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습이라 이름이 '버블'로 붙여졌다. 버블정렬은 붙어 있는 두 수의 크고 작음을 비교해 필요에 따라 교환을 반복하는 알고리즘이다. (단순 교환 정렬이라고도 불린다.) 만약 배열이 하나 있다면 그 안에 인접한 두 개의 수를 선택한 뒤, 만약 그 두 수가 정렬되었다면 놔두고 아니라면 두 수를 바꾸는 식으로 진행한다. 두 수를 a,b로 두었을 때 오름차순으로 정렬한다면 'a < b', 내림차순이라면 'b < a'로 정렬된 걸로 판단한다. (이걸 배열의 처음부터 끝까지 반복한다...) 

만약 아래와 같은 배열을 오름차순으로 해야한다면 7,2를 먼저 비교한다.

<br/>

```javascript

[7,2,0,1,5,6,4]
```

<br/>

비교하면 7이 2보다 크기 때문에 배열은 [2,7,0,1,5,6,4] 가 된다. 이 상태에서 계속 비교를 한다면 아래와 같이 정리된다. 

<br/>

```javascript

[2,0,1,5,6,4,7]

...

//최종 결과
[0,1,2,4,5,6,7]

```
<br/>

가장 큰 수인 7이 정리되었으니 다시 맨 앞의 2와 0을 비교해준다. 이런 식으로 계속 반복해주다보면 오름 차순으로 예쁘게 정렬된 배열이 나온다. 자바스크립트 코드로 한다면 아래와 같다!

<br/>

```javascript

let sort_arr = [7,2,0,1,5,6,4];

function bubbleSort(arr) {
    let temp = 0;
    for(let i = 0; i < arr.length; i++) {      
        for(let j = 1; j < arr.length - i; j++) { 
            if(arr[j - 1] > arr[j]) {            
                // arr[j-1] arr[j] 교환
                temp = arr[j - 1];
                arr[j - 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    console.log(arr);
}

bubbleSort(sort_arr)
```

<br/>


### #선택 정렬(Selection Sort)

<br/>

선택 정렬은 가장 작은 값을 찾은 뒤, 그 값을 맨 앞에 위치한 값과 교체(=pass)해 알맞은 위치로 옮기는 작업을 반복해 정렬하는 알고리즘이다. 선택 정렬도 버블정렬과 같이 간단하지만 시간복잡도가 O(n^2) 이기 때문에 사용할 수 있는 메모리가 제한적인 경우에 성능 상 이점을 볼 수 있다. 예를 들어 정렬되지 않은 배열에서 가장 작은 값이 a[min]이라면, a[min]과 아직 정렬하지 않은 부분 중 맨 앞에 있는 원소와 교환한다. 이 교환을 반복해서 정렬하는 게 선택정렬이다. 이 예시는 아래 문장으로 정리해볼 수 있다.

<br/>

```
for i = 0 to n:
    a[i]부터 a[n - 1]까지 차례로 비교하여 가장 작은 값이 a[j]에 있다고 하자.
    a[i]와 a[j]의 값을 서로 맞바꾼다.

ex)

[6,4,8,3,1,9,7] //1이 최소값
-> pass (교환!)
[1,4,8,3,6,9,7] //3이 최소값
-> pass
[1,3,8,4,6,9,7] //4가 최소값
-> pass
    
...

[1,3,4,6,7,8,9] //정렬완료!

```

<br/>

선택정렬은 정렬하려고 하는 배열 안에서 교환하는 방식이라 다른 메모리 공간을 필요로 하지 않는다. (배열에서 자리를 선택하고 그 자리에 오는 값을 찾는 방식!) 자바스크립트는 아래와 같이 구현할 수 있다.

<br/>

```javascript

function selectionSort(arr) {
    let indexMin, temp;
    for (let i = 0; i < arr.length - 1; i++) {     
        indexMin = i;
        for (let j = i + 1; j < arr.length; j++) {  
            if (arr[j] < arr[indexMin]) {          
                indexMin = j;
            }
        }
        temp = arr[indexMin];
        arr[indexMin] = arr[i];
        arr[i] = temp;
    }
    console.log(arr);
}

// 예시 배열
const array = [64, 34, 25, 12, 22, 11, 90];
selectionSort(array); // 정렬된 배열을 콘솔에 출력


```


<br/>

### #삽입 정렬(Insertion Sort)

<br/>

삽입 정렬은 자료의 앞에서부터 차례대로 이미 정렬된 부분과 비교하며, 자신의 위치를 찾아 '삽입'하며 정렬을 완성하는 알고리즘이다. 2번째 원소부터 시작해 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 삽입해 정렬한다. 전체를 탐색하는 선택 정렬과 달리 필요한 만큼의 요소만 탐색하기 때문에 훨씬 더 효율적으로 실행된다. 최선의 경우 O(n) 이라는 최적의 시간복잡도를 가진다. 아래는 위키피디아에서 제시한 삽입 정렬 예시이다.

<br/>

```
//처음 상태
31 25 12 22 11			

//두 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
31 [25] 12 22 11	 

//세 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<25> 31 [12] 22 11
 	
//네 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<12> 25 31 [22]	11		 	

//마지막 원소를 부분 리스트에서 적절한 위치에 삽입한다.
12 <22>	25 31 [11]		

//종료
<11> 12	22 25 31		 	

```

<br/>

자바스크립트 코드로는 아래와 같이 구현할 수 있다.

<br/>

```javacscript

function insertionSort(arr) {
  for (let index = 1; index < arr.length; index++) {
    let temp = arr[index];
    let aux = index - 1;

    while (aux >= 0 && arr[aux] > temp) {
      arr[aux + 1] = arr[aux];
      aux--;
    }
    arr[aux + 1] = temp;
  }
}

// 예시 배열
const array = [64, 34, 25, 12, 22, 11, 90];
insertionSort(array);
console.log(array); // 정렬된 배열 출력


```

<br/>

### #퀵 정렬(Quick Sort)

<br/>

퀵 정렬은 <i>1)찰스 앤터니 리처드 호어</i> 가 개발한  정렬 알고리즘이다. 다른 원소와 비교만으로 정렬을 수행하는 <i>2)비교 정렬</i> 에 속한다. 퀵 정렬은 리스트 가운데에서 피벗(pivot) 값을 고른 뒤, 피벗을 기준으로 큰 숫자와 작은 숫자를 분리한다. 이렇게 리스트를 둘로 나누는 걸 '분할'이라고 하며 분할된 두 리스트 각 부분을 다시 정렬하는 방식으로 작동한다. 퀵 정렬의 내부 루프는 컴퓨터 아키텍처에서 효율적으로 작동하도록 설게 되어 있다. <i>3)(메모리 참조가 지역화 되어 있기 때문에 CPU 캐시의 히트율이 높아지기 때문이다.)</i>

<br/>

즉, 퀵 정렬은 데이터를 효율적으로 나누고 처리하는 방식이기 때문에 메모리 상에서 연속적으로 데이터에 접근할 수 있게 한다. 책을 잘 정리해서 필요한 책을 빨리 찾을 수 있게 하는 정리법과 비슷하다.

<br/>

---

1)찰스 앤터지 리처드 호어?
:영국의 컴퓨터 과학자.1934년 출생. 1960년 엘리엇 브라더스라는 작은 컴퓨터 제조 회사에 취직하여, 알골 60 프로그램을 개발했으며 알고리즘의 개발에 본격적으로 착수하였다. 1980년 프로그래밍 언어의 정의와 설계에 대한 공헌을 인정 받아 ACM 튜링 상을 수상하였다.

<br/>

2)비교정렬?
:원소들을 정렬할 때 원소들의 순서에만 의존하는 알고리즘을 말한다. 버블 정렬은 원소가 숫자든 문자열이든 순서가 결정되어 있다면 적용할 수 있다. 비교 정렬 알고리즘의 최악의 시간 복잡도는 O(n log n)이다. 

<br/>

3)메모리 참조가 지역화? / CPU 캐시? / 히트율?

- 메모리 참조의 지역성(Locality of Reference)은 '어떤 데이터가 참조되면, 참조된 그 지역 및 시간 근처에서 다시 참조될 가능성이 높다는 원칙이다. 
  -   시간적 지역성(Temporal Locality): 한 번 참조된 데이터는 곧 다시 참조될 가능성이 높다.
  - 공간적 지역성(Spatial Locality): 메모리 상에서 서로 가까이 있는 데이터들은 함께 참조될 가능성이 높다.

<br/>

- CPU 캐시
    - CPU와 메모리 사이에 있는 작고 빠른 저장 공간.
    - 자주 사용되는 데이터나 명령어를 미리 캐시에 저장해두면, CPU가 필요할 때 빠르게 접근할 수 있다. 

<br/>

- 히트율(Cache Hit Rate)
  - CPU가 데이터나 명령어를 캐시에서 바로 찾아낼 수 있는 비율을 의미한다. 히트율이 높을수록 더 빠른 성능을 보인다. 

<br/>

---

위키피디아에서 제시한 예시는 아래와 같다. 

피벗은 p, 리스트 왼쪽 끝과 오른쪽 끝에서 시작한 인덱스들을 i,j라고 하자.

```
5 - 3 - 7 - 6 - 2 - 1 - 4(여기가 p)
```

리스트 왼쪽에 있는 i 위치의 값이 피벗 값보다 크고, 오른쪽에 있는 j 위치의 값은 피벗 값보다 작으므로 둘을 교환한다.

```
5(i) - 3 - 7 - 6 - 2 - 1(j) - 4(p)

1(i) - 3 - 7 - 6 - 2 - 5(j) - 4(p)
```

j 위치의 값이 피벗 값보다 작지만, i 위치의 값도 피벗값보다 작으므로 교환하지 않는다.

```
1 - 3(i) - 7 - 6 - 2(j) - 5 - 4(p) 
```

i위치를 피벗 값보다 큰 값이 나올 때까지 진행해 j 위치의 값과 교환한다.

```
1 - 3 - 7(i) - 6 - 2(j) - 5 - 4(p)

1 - 3 - 2(i) - 6 - 7(j) - 5 - 4(p) 
```
i위치가 j 위치보다 커지면, i 위치의 값과 피벗 값을 교환한다.

```
1 - 3 - 2 - 6 - 7 - 5 - 4(p)

1 - 3 - 2 - 4(p) - 7 - 5 - 6 
```               
피벗 값 좌우의 리스트에 대해 각각 퀵 정렬을 재귀적으로 수행한다.

```
1 - 3 - 2       7 - 5 - 6
1 - 2 - 3       5 - 6 - 7
```

완성된 리스트는 다음과 같다.

```
1 - 2 - 3 - 4 - 5 - 6 - 7
```

<br/>

위의 코드는 아니지만 퀵 정렬의 분할 관련해 코드를 짜본다면 아래와 같다

```javascript
function quickSort(arr) {
  // 배열의 길이가 1 이하이면, 그대로 반환.
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[0]; // 배열의 첫 번째 요소를 피벗으로 선택.
  const left = []; // 피벗보다 작은 요소들을 담을 배열.
  const right = []; // 피벗보다 큰 요소들을 담을 배열.

  // 첫 번째 요소를 제외한 나머지 요소들을 피벗과 비교하여 분류.
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  // 재귀적으로 left와 right 배열을 정렬하고, 최종적으로 합쳐서 반환.
  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 사용 예:
const arr = [5, 3, 7, 6, 2, 1, 4];
console.log(quickSort(arr)); // 출력: [1, 2, 3, 4, 5, 6, 7]


```

<br/>

### #병합 정렬(Merge Sort)

<br/>

병합정렬은 비교 기반 정렬 알고리즘이다. <i>4)분할 정복 알고리즘</i> 에 속하며 시간 복잡도는 O(n log n)이다. <i>5)존 폰 노이만</i>이 1945년에 개발했다. 빠른 정렬로 분류 되어 퀵 정렬과 함께 많이 언급되는 정렬 방식이다. 퀵 정렬과의 차이점은 퀵 정렬은 피벗을 통해 정렬한 후 영역을 쪼개는 식이지만, 병합 정렬은 영역을 쪼갤 수 있을 만큼 쪼갠 뒤 정렬한다는 점이다. 

<br/>

병합 정렬은 자료를 여러 부분 집합으로 분할하고 각각 정렬한 다음에, 이를 병합하면서 정렬한다. 정렬되지 않은 리스트에서 하나의 원소만을 포함하는 n개의 부분리스트로 분할한 뒤, 부분 리스트가 하나만 남을 때까지 반복해서 병합한다. 이렇게 병합해 정렬된 마지막 부분리스트가 정렬된 리스트이다. 

---

4) 분할 정복 알고리즘(Divide and conquer algorithm)
: 해결할 수 없는 문제를 작은 문제로 분할해 문제를 해결하는 알고리즘. 빠른 정렬이나 합병 정렬로 대표 되는 정렬 알고리즘 문제가 대표적이다. 

<br/>

5) 존 폰 노이만
: 헝가리 출신의 미국에서 활동한 경제학자, 컴퓨터과학자, 수학자. 컴퓨터 과학에서의 업적으로는 합병 정렬 알고리즘과 현대 컴퓨터 설계의 기반이 된 '폰 노이만 구조'가 있다. 

---

<br/>

자바스크립트 코드는 아래와 같다!

<br/>

```javascript

function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const middle = Math.floor(arr.length / 2); // 배열을 반으로 나누기 위한 중간 지점을 계산합니다.
  const left = arr.slice(0, middle); // 중간 지점을 기준으로 왼쪽 부분 배열을 생성합니다.
  const right = arr.slice(middle); // 중간 지점을 기준으로 오른쪽 부분 배열을 생성합니다.

  // merge 함수를 사용하여 정렬된 왼쪽 부분과 오른쪽 부분을 하나로 병합합니다.
  return merge(mergeSort(left), mergeSort(right));
}

// 두 배열을 받아 하나의 정렬된 배열로 병합하는 함수입니다.
function merge(left, right) {
  let result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 왼쪽 배열과 오른쪽 배열을 순회하며, 각각의 요소를 비교하여
  // 더 작은 값을 결과 배열에 순차적으로 추가합니다.
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++; // 왼쪽 배열의 인덱스를 증가시킵니다.
    } else {
      result.push(right[rightIndex]);
      rightIndex++; // 오른쪽 배열의 인덱스를 증가시킵니다.
    }
  }

  // 남아 있는 요소들을 결과 배열에 추가합니다.
  // 왼쪽 배열이나 오른쪽 배열 중 하나가 먼저 끝나면, 나머지 배열의 남은 요소들을
  // 모두 결과 배열에 추가합니다.
  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}

// 사용 예:
const arr = [5, 3, 7, 6, 2, 1, 4];
console.log(mergeSort(arr)); // 출력: [1, 2, 3, 4,


```

<br/>


📌 참고

- https://ko.wikipedia.org/wiki/%EC%A0%95%EB%A0%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
- https://ko.wikipedia.org/wiki/%EB%B2%84%EB%B8%94_%EC%A0%95%EB%A0%AC
- https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC
- https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC
- https://ko.wikipedia.org/wiki/%ED%86%A0%EB%8B%88_%ED%98%B8%EC%96%B4
- https://ko.wikipedia.org/wiki/%EB%B6%84%ED%95%A0_%EC%A0%95%EB%B3%B5_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
- http://www.ktword.co.kr/test/view/view.php?m_temp1=6231
- 책 <자료구조와 함께 배우는 알고리즘 입문(파이썬)>
- https://gyoogle.dev/blog/algorithm/Selection%20Sort.html
- And ChatGPT👾



<br/>
<br/>